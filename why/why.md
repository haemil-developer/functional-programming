### Before Start Functional Programming
- 1967년 시뮬라67은 최초의 객체지향 언어지만, 1983년 C++가 보편화된 후에야 주류가 되었다. 
- 자바는 초창기에 느리고 메모리를 과하게 사용해서 고성능 애플리케이션용으로는 적합하지 안하고 여겨졌다. 하지만 하드웨어 시장의 변화로 선호도가 높아졌다.
- 함수형 프로그래밍은 객체지향과 개념적으로 같은 궤도를 따른다.

## 객체지향(명령형, OOP) VS 함수형 언어
### 객체지향 언어
- 캡슐화, 스코핑, 가시성 등의 메커니즘은 상태(state) 변화를 누가 볼 수 있는지에 대한 세밀한 제어를 위해 존재 (+ thread 까지)  -> 움직이는 부분
- 재사용의 단위틑 Class와 그 클래스들이 주고받는 통신 메시지.
- 자료구조에 특정 동작을 메서드의 형태로 부착해서 고유한 자료구조를 작성하는것을 권장한다.
- 새로운 자료구조와 그것에 부착된 메서드를 만든다.


### 함수형 언어
- 불변 (mutable) 상태를 제어하는 메커니즘을 구축하기보다, '움직이는 부분'을 아예 제거하는데 주력.
- 오류가 발생하기 쉬운 기능을 적게 노출하면 개발자가 오류를 만들 가능성이 줄어든다는 이론.
- 같은 방식의 재사용을 달성하려 하지 않고, 최적화된 동작으로 몇몇 자료구조(list, set, map) 를 이용하는 방식으로 재사용을 선호한다.
- 특정 용도로 정의된 방법에 자료구조와 고계함수를 함께 넣어야 한다.

```
regexToList(words, "\\w+").stream()
                .filter(w -> !NON_WORDS.contains(w))
```

- 목록의 일부를 꺼내려면 스트림 형태의 복록과 필터 조건이 구현된 고계함수를 넣어서 filter() 메서드를 호출하면 된다.
- 함수 수준의 캡슐화는, 모든 문제에 대한 새로운 클래스 구조를 구축하는 것 보다 세분화되고 기초적인 수준에서 재사용을 가능하게 한다.
- 클로저 최근 라이브러리들은 map 함수를 재구현하여 자동 병렬화가 가능해져서, 개발자 개입 없이도 모든
- 적은 수의 자료구조와 그것을 잘 이해하기 위한 최적화된 방법을 만들기를 선호한다.

